[
{
"queries": [
"Eq(IpVersion_1, 4) | Eq(IpVersion_1, 6)",
"Eq(IpVersion_2, 4) | Eq(IpVersion_2, 6)",
"Eq(IpVersion_3, 4) | Eq(IpVersion_3, 6)"
],
"description": "IP version must be either 4 or 6 for all packets"
},

{
"queries": [
"Implies(Eq(TcpFlags_1, 2) & Eq(TcpFlags_2, 18) & Eq(TcpFlags_3, 16) & Eq(IpSrc_2, IpDst_1) & Eq(IpDst_2, IpSrc_1) & Eq(TcpSrcport_1, TcpDstport_2) & Eq(TcpSrcport_2, TcpDstport_1), Eq(TcpAck_2, TcpSeq_1 + 1) & Eq(TcpSeq_3, TcpAck_2) & Eq(TcpAck_3, TcpSeq_2 + 1))"
],
"description": "Three-way handshake with expected ACK/SEQ relationships"
},

{
"queries": [
"Implies( Eq(TcpFlags_1, 24) & Eq(IpSrc_2, IpDst_1) & Eq(IpDst_2, IpSrc_1) & Eq(TcpSrcport_1, TcpDstport_2) & Eq(TcpSrcport_2, TcpDstport_1), Eq(TcpFlags_2, 4) | Eq(TcpFlags_2, 16) | Eq(TcpFlags_2, 17) | Eq(TcpFlags_2, 18) | Eq(TcpFlags_2, 20) | Eq(TcpFlags_2, 24) | Eq(TcpFlags_2, 25))"
],
"description": "PSH-ACK packet is followed by appropriate ACK-related flags"
},

{
"queries": [
"Implies(Eq(TcpFlags_1, 17) & (TcpAck_2 != TcpSeq_1 + 1) & Eq(IpSrc_2, IpDst_1) & Eq(IpDst_2, IpSrc_1) & Eq(TcpSrcport_1, TcpDstport_2) & Eq(TcpSrcport_2, TcpDstport_1), Eq(TcpFlags_2, 4) | Eq(TcpFlags_2, 16) | Eq(TcpFlags_2, 17) | Eq(TcpFlags_2, 18) | Eq(TcpFlags_2, 20) | Eq(TcpFlags_2, 24) | Eq(TcpFlags_2, 25))"
],
"description": "FIN-ACK -> ACK-related flags Sequence"
},

{
"queries": [
"Implies(Eq(TcpLen_2, 0) & Eq(TcpFlags_2, 16) & Eq(IpSrc_2, IpDst_1) & Eq(IpDst_2, IpSrc_1) & Eq(TcpSrcport_1, TcpDstport_2) & Eq(TcpSrcport_2, TcpDstport_1), Eq(TcpSeq_2, TcpAck_1))"
],
"description": "Pure ACK with no payload correctly acknowledges the first packet"
},

{
"queries": [
"Implies(Eq(IpDst_1, IpSrc_2) & Eq(IpSrc_1, IpDst_2) & Eq(TcpSeq_2, TcpAck_1) & (TcpSeq_2 > 1), Eq(TcpDstport_1, TcpSrcport_2) & Eq(TcpSrcport_1, TcpDstport_2))"
],
"description": "Packet 1 and 2 form a flow-consistent request-response pair (not part of handshake)"
},

{
"queries": [
"Implies(Eq(IpDst_2, IpSrc_3) & Eq(IpSrc_2, IpDst_3) & Eq(TcpSeq_3, TcpAck_2) & (TcpSeq_3 > 1), Eq(TcpDstport_2, TcpSrcport_3) & Eq(TcpSrcport_2, TcpDstport_3))"
],
"description": "Packet 2 and 3 form a flow-consistent request-response pair (not part of handshake)"
},

{
"queries": [
"Implies(Eq(TcpFlags_1, 2) & Eq(TcpFlags_2, 18) & Eq(TcpFlags_3, 16), Eq(TcpAck_1, TcpSeq_2) & Eq(TcpAck_2, TcpSeq_3) & Eq(TcpSeq_3, 1))"
],
"description": "Three-way handshake with phantom sequence and acknowledgment values"
},

{
"queries": [
"Eq(IpLen_1, IpHdrLen_1 + TcpHdrLen_1 + TcpLen_1)",
"Eq(IpLen_2, IpHdrLen_2 + TcpHdrLen_2 + TcpLen_2)",
"Eq(IpLen_3, IpHdrLen_3 + TcpHdrLen_3 + TcpLen_3)"
],
"description": "IP total length must equal IP header + TCP header + TCP payload length"
},

{
"queries": [
"Eq(TcpWindowSizeValue_1 * TcpWindowSizeScalefactor_1, TcpWindowSize_1)",
"Eq(TcpWindowSizeValue_2 * TcpWindowSizeScalefactor_2, TcpWindowSize_2)",
"Eq(TcpWindowSizeValue_3 * TcpWindowSizeScalefactor_3, TcpWindowSize_3)"
],
"description": "TCP window scaling factor applied to raw value equals actual window size"
},

{
"queries": [
"Implies(TcpUrgentPointer_1 > 0, TcpFlags_1 >= 20)",
"Implies(TcpUrgentPointer_2 > 0, TcpFlags_2 >= 20)",
"Implies(TcpUrgentPointer_3 > 0, TcpFlags_3 >= 20)"
],
"description": "URG/RST flag must be set (min of URG=32 and RST=20) when TCP Urgent Pointer is non-zero"
},

{
"queries": [
"Implies(Eq(TcpFlags_1, 2) & Eq(TcpFlags_2, 18) & Eq(TcpFlags_3, 16), (TcpWindowSize_1 > 0) & (TcpWindowSize_3 > 0))"
],
"description": "TCP window size must be non-zero during handshake (packets 1 and 3)"
},

{
"queries": [
"Implies(Eq(TcpFlags_1, 2) & Eq(TcpFlags_2, 18) & Eq(TcpFlags_3, 16), Eq(TcpLen_1, 0) & Eq(TcpLen_2, 0))"
],
"description": "SYN and SYN-ACK should not contain TCP payload"
},

{
"queries": [
"FrameLen_1 > IpLen_1",
"FrameLen_2 > IpLen_2",
"FrameLen_3 > IpLen_3"
],
"description": "Total frame length should be greater than encapsulated IP length"
},
{
"description": "IP TTL Sanity Rule",
"queries": [
"And(IpTtl_1 > 0, IpTtl_1 <= 255)",
"And(IpTtl_2 > 0, IpTtl_2 <= 255)",
"And(IpTtl_3 > 0, IpTtl_3 <= 255)"
]
},
{
"description": "IP/TCP Header Length Alignment (Multiple of 4 bytes)",
"queries": [
"Eq(Mod(IpHdrLen_1, 4), 0)",
"Eq(Mod(IpHdrLen_2, 4), 0)",
"Eq(Mod(IpHdrLen_3, 4), 0)",
"Eq(Mod(TcpHdrLen_1, 4), 0)",
"Eq(Mod(TcpHdrLen_2, 4), 0)",
"Eq(Mod(TcpHdrLen_3, 4), 0)"
]
}
]
